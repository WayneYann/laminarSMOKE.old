Info<< "Reading Solver options\n" << endl;
IOdictionary solverOptions
(
	IOobject
	(
		"solverOptions",
		U.time().constant(),
		U.db(),
		IOobject::MUST_READ,
		IOobject::NO_WRITE
	)
);

label inertIndex;
OpenSMOKE::ThermodynamicsMap_CHEMKIN<double>*			thermodynamicsMapXML; 
OpenSMOKE::KineticsMap_CHEMKIN<double>* 				kineticsMapXML;
OpenSMOKE::TransportPropertiesMap_CHEMKIN<double>* 		transportMapXML;

const dictionary& kineticsDictionary = solverOptions.subDict("Kinetics");
{
	//- Kinetics folder
	Foam::string kinetics_folder = kineticsDictionary.lookup("folder");

	// Reading homogeneous data
	Info<< " * loading homogeneous kinetics...\n" << endl;
	{	
		word kinetics("opensmoke");
		boost::filesystem::path path_kinetics = kinetics_folder;

		rapidxml::xml_document<> doc;
		std::vector<char> xml_string;
		OpenSMOKE::OpenInputFileXML(doc, xml_string,path_kinetics / "kinetics.xml");

		double tStart = OpenSMOKE::OpenSMOKEGetCpuTime();
		
		thermodynamicsMapXML = new OpenSMOKE::ThermodynamicsMap_CHEMKIN<double>(doc); 
		transportMapXML = new OpenSMOKE::TransportPropertiesMap_CHEMKIN<double>(doc); 
		kineticsMapXML = new OpenSMOKE::KineticsMap_CHEMKIN<double>(*thermodynamicsMapXML, doc); 
							
		double tEnd = OpenSMOKE::OpenSMOKEGetCpuTime();
		std::cout << " * Time to read XML file: " << tEnd-tStart << std::endl;
	}

	//- Inert species
	word inertSpecies(kineticsDictionary.lookup("inertSpecies"));
	inertIndex = thermodynamicsMapXML->IndexOfSpecies(inertSpecies)-1;
}

//- Mass fractions tolerance
scalar massFractionsTol = 1e-10;

//- Internal models
enum { STRANG_MOMENTUM_TRANSPORT_REACTION, STRANG_MOMENTUM_REACTION_TRANSPORT} strangAlgorithm;
enum { DIFFUSIVITY_MODEL_MULTICOMPONENT, DIFFUSIVITY_MODEL_LEWIS_NUMBERS} diffusivityModel;

// Physical model
Switch energyEquation;
Switch speciesEquations;
Switch momentumEquations;
Switch zMixEquation;
Switch tauEquation;
Switch homogeneousReactions;
Switch iMassDiffusionInEnergyEquation;
Switch constPressureBatchReactor;
Switch includeDpDt;
Switch soretEffect;
Switch thermophoreticEffect;
Eigen::VectorXd LewisNumbers;
std::vector<bool> soretEffectList;
std::vector<int> indexSoret;
scalar thermodynamicPressure = 101325.;
label zMixDmixIndex = inertIndex;

const dictionary& physicalModelDictionary = solverOptions.subDict("PhysicalModel");
{
	momentumEquations = Switch(physicalModelDictionary.lookup(word("momentumEquations")));
	energyEquation = Switch(physicalModelDictionary.lookup(word("energyEquation")));
	speciesEquations = Switch(physicalModelDictionary.lookup(word("speciesEquations")));
	tauEquation = Switch(physicalModelDictionary.lookup(word("tauEquation")));
	zMixEquation = Switch(physicalModelDictionary.lookup(word("zMixEquation")));
	homogeneousReactions = Switch(physicalModelDictionary.lookup(word("homogeneousReactions")));
	includeDpDt = Switch(physicalModelDictionary.lookup(word("includeDpDt")));
	iMassDiffusionInEnergyEquation = Switch(physicalModelDictionary.lookup(word("massDiffusionInEnergyEquation")));
	
	// Thermophoretic effect
	thermophoreticEffect = Switch(physicalModelDictionary.lookup(word("thermophoreticEffect")));

	// Soret effect
	soretEffect = Switch(physicalModelDictionary.lookup(word("soretEffect")));
	soretEffectList.resize(thermodynamicsMapXML->NumberOfSpecies());
	indexSoret.resize(thermodynamicsMapXML->NumberOfSpecies());

	for(unsigned int i=0;i<thermodynamicsMapXML->NumberOfSpecies();i++)
		soretEffectList[i] = false;	
	for(unsigned int i=0;i<thermodynamicsMapXML->NumberOfSpecies();i++)
		indexSoret[i] = -1;
	
	// Algorithm
	{
		word strang(physicalModelDictionary.lookup("strangAlgorithm"));
		if (strang == "MomentumTransportReaction")	strangAlgorithm = STRANG_MOMENTUM_TRANSPORT_REACTION;
		else if (strang == "MomentumReactionTransport")	strangAlgorithm = STRANG_MOMENTUM_REACTION_TRANSPORT;
		else
		{
			Info << "Wrong strangAlgorithm option: MomentumTransportReaction || MomentumReactionTransport" << endl;
			abort();
		}
	}
	
	// Diffusivity of species
	{
		word diffusivity(physicalModelDictionary.lookup("diffusivityModel"));
		if (diffusivity == "multi-component")		diffusivityModel = DIFFUSIVITY_MODEL_MULTICOMPONENT;
		else if (diffusivity == "lewis-numbers")	diffusivityModel = DIFFUSIVITY_MODEL_LEWIS_NUMBERS;
		else
		{
			Info << "Wrong diffusivityModel option: multi-component || lewis-numbers" << endl;
			abort();
		}
		
		if (diffusivityModel == DIFFUSIVITY_MODEL_LEWIS_NUMBERS)
		{
			LewisNumbers.resize(thermodynamicsMapXML->NumberOfSpecies());
			
			const dictionary& lewisNumberDictionary = solverOptions.subDict("LewisNumbers");
			for(int i=0;i<thermodynamicsMapXML->NumberOfSpecies();i++)
				LewisNumbers(i) = readScalar(lewisNumberDictionary.lookup(thermodynamicsMapXML->NamesOfSpecies()[i]));
			
			Info << endl;
			Info << "Diffusivities of species will be calculated using the following Lewis numbers: " << endl;
			for(int i=0;i<thermodynamicsMapXML->NumberOfSpecies();i++)
				Info << " " << thermodynamicsMapXML->NamesOfSpecies()[i] << "\t" << LewisNumbers(i) << endl;
			Info << endl;
		}
	}
	
	//- Constant pressure reactors
	constPressureBatchReactor = Switch(physicalModelDictionary.lookup(word("constPressureBatchReactor")));

	// Themodynamic pressure [Pa]
	thermodynamicPressure = readScalar(physicalModelDictionary.lookup("thermodynamicPressure"));

	//- Inert species
	if (zMixEquation == true)
	{
		word referenceSpecies(physicalModelDictionary.lookup("zMixDmixSpecies"));
		zMixDmixIndex = thermodynamicsMapXML->IndexOfSpecies(referenceSpecies)-1;
	}
}

//- Detect spark
const dictionary& sparkDictionary = solverOptions.subDict("Spark");
sparkModel spark;
spark.Read(sparkDictionary);

Eigen::VectorXd outputFormationRatesIndices;
Eigen::VectorXd outputDiffusivitiesIndices;
const dictionary& outputDictionary = solverOptions.subDict("Output"); 
{
	{
		Switch outputFormationRates = Switch(outputDictionary.lookup(word("formationRates")));
		if (outputFormationRates == true)
		{
			List<word>  listFormationRates(outputDictionary.lookup("listFormationRates"));
			outputFormationRatesIndices.resize(listFormationRates.size());
			for (int i=0;i<listFormationRates.size();i++)
				outputFormationRatesIndices(i) = thermodynamicsMapXML->IndexOfSpecies(listFormationRates[i])-1;
		}
	}

	{
		Switch outputDiffusivities = Switch(outputDictionary.lookup(word("diffusivities")));
		if (outputDiffusivities == true)
		{
			List<word>  listDiffusivities(outputDictionary.lookup("listDiffusivities"));
			outputDiffusivitiesIndices.resize(listDiffusivities.size());
			for (int i=0;i<listDiffusivities.size();i++)
				outputDiffusivitiesIndices(i) = thermodynamicsMapXML->IndexOfSpecies(listDiffusivities[i])-1;
		}
	}
}

// Thermophoretic effect
std::vector<bool> thermophoreticEffectList;
Switch physicalSootDiffusivity = false;
label  physicalSootDiffusivityReferenceIndex = -1;
std::vector<double> physicalSootDiffusivityCorrection;
std::vector<int> physicalSootDiffusivityCorrectionIndex;
{ 
	const dictionary& polimiSootDictionary = solverOptions.subDict("PolimiSoot");

	if (thermophoreticEffect == true)
	{
		thermophoreticEffectList.resize(thermodynamicsMapXML->NumberOfSpecies());
		for(unsigned int i=0;i<thermodynamicsMapXML->NumberOfSpecies();i++)
			thermophoreticEffectList[i] = false;

		// Populate the list of thermophoretic species
		if (thermophoreticEffect == true)
		{
			word tag = polimiSootDictionary.lookup(word("thermophoreticEffectTag"));	
	
			unsigned int count = 0;
			for(unsigned int i=0;i<thermodynamicsMapXML->NumberOfSpecies();i++)
			{
				std::string name = thermodynamicsMapXML->NamesOfSpecies()[i];
				std::string prefix = name.substr(0,tag.size());
				if (prefix == tag)
				{
					thermophoreticEffectList[i] = true;
					count++;
				}
			}
				
			if (count == 0)
				std::cout << "Warning: No " << tag << " species were found in the kinetic scheme! Are you sure you want to account for the thermophoretic effect?" << std::endl;
			else
				std::cout << "Thermophoretic effect: Number of " << tag << " species found equal to " << count << std::endl;
		}
	}

	physicalSootDiffusivity = Switch(polimiSootDictionary.lookup(word("physicalSootDiffusivity")));

	if (physicalSootDiffusivity == true)
	{
		//scalar physicalSootDiffusivityExponent = readScalar(polimiSootDictionary.lookup("exponent"));
		scalar physicalSootDiffusivityExponent = -0.681;
		label physicalSootDiffusivityIndex = readLabel(polimiSootDictionary.lookup("physicalSootDiffusivityIndex"));

		for(unsigned int i=0;i<thermodynamicsMapXML->NumberOfSpecies();i++)
		{
			if (thermodynamicsMapXML->NamesOfSpecies()[i] == "BIN1A")
			{
				physicalSootDiffusivityReferenceIndex = i;
				break;
			}
		}
		if (physicalSootDiffusivityReferenceIndex == -1)
		{
			Info << "Species BIN1A is not included in the kinetic mechanism" << endl;
			abort();
		}
		else
		{
			int count = -1;
			for(unsigned int i=0;i<thermodynamicsMapXML->NumberOfSpecies();i++)
			{
				if (thermodynamicsMapXML->NamesOfSpecies()[i].compare(0,3,"BIN") == 0)
				{
					count++;
					double MWratio = std::min(	thermodynamicsMapXML->MW()[i+1]/thermodynamicsMapXML->MW()[physicalSootDiffusivityReferenceIndex+1], 
									std::pow(2., double(physicalSootDiffusivityIndex)) );
					physicalSootDiffusivityCorrection.push_back( std::pow(MWratio, physicalSootDiffusivityExponent) );
					physicalSootDiffusivityCorrectionIndex.push_back(i);
			
					Info << "Physical diffusion coefficient: " << thermodynamicsMapXML->NamesOfSpecies()[i] << " : " << physicalSootDiffusivityCorrection[count] << endl;
				}
			}
		}
	}
} 

// Soot post-processing
OpenSMOKE::PolimiSoot_Analyzer* sootAnalyzer;
Switch iPolimiSoot = false;
label sootIntegralUpdate  = 1;
label sootIntegralCounter = sootIntegralUpdate;
Switch sootOnTheFlyFill = false;
autoPtr<std::ofstream> fSootIntegrals;
//List<vector> pnts_soot_psdf;
{	
		const dictionary& postProcessingDictionary = solverOptions.subDict("PostProcessing");		
		iPolimiSoot = Switch(postProcessingDictionary.lookup(word("soot")));

		if (iPolimiSoot == true)
		{
			const dictionary& postProcessingPolimiSootDictionary = postProcessingDictionary.subDict("PolimiSoot");
			
			sootOnTheFlyFill    = Switch(postProcessingPolimiSootDictionary.lookup(word("onTheFlyFill")));
			sootIntegralUpdate  = readLabel(postProcessingPolimiSootDictionary.lookup("integralUpdate"));
			sootIntegralCounter = sootIntegralUpdate;

			Foam::string minimum_bin = postProcessingPolimiSootDictionary.lookup("binMinimum");
			label bin_index_zero     = readLabel(postProcessingPolimiSootDictionary.lookup("binIndexZero"));
			label bin_index_final    = readLabel(postProcessingPolimiSootDictionary.lookup("binIndexFinal"));
			scalar bin_density_zero  = readScalar(postProcessingPolimiSootDictionary.lookup("binDensityZero"));
			scalar bin_density_final = readScalar(postProcessingPolimiSootDictionary.lookup("binDensityFinal"));
			scalar fractal_diameter  = readScalar(postProcessingPolimiSootDictionary.lookup("fractalDiameter"));
			Foam::string planck_coefficient = postProcessingPolimiSootDictionary.lookup("planckCoefficient");

			sootAnalyzer = new OpenSMOKE::PolimiSoot_Analyzer(thermodynamicsMapXML);
			sootAnalyzer->SetFractalDiameter(fractal_diameter);
			sootAnalyzer->SetMinimumSection(minimum_bin);
			sootAnalyzer->SetDensity(bin_index_zero, bin_index_final, bin_density_zero, bin_density_final);
			sootAnalyzer->SetPlanckAbsorptionCoefficient(planck_coefficient);
			sootAnalyzer->Setup();

			// Particle size distribution function
			// List<vector> pnts_soot_psdf_dummy(postProcessingPolimiSootDictionary.lookup("PSDF"));
			// pnts_soot_psdf = pnts_soot_psdf_dummy;

			// Soot integrals
			if ( !boost::filesystem::exists("soot.integrals") )
			{
  				fSootIntegrals.reset(new std::ofstream("soot.integrals", std::ios::out));
				fSootIntegrals().setf(std::ios::scientific);

				fSootIntegrals() << std::setw(20) << "time";
				fSootIntegrals() << std::setw(20) << "soot_mass[kg]";
				fSootIntegrals() << std::setw(20) << "soot_volume[m3]";
				fSootIntegrals() << std::setw(20) << "soot_particles[#]";		
				fSootIntegrals() << std::setw(20) << "prec_mass[kg]";
				fSootIntegrals() << std::setw(20) << "prec_volume[m3]";
				fSootIntegrals() << std::setw(20) << "prec_partciles[#]";
				fSootIntegrals() << std::setw(20) << "dimer_mass[kg]";		
				fSootIntegrals() << std::setw(20) << "pah12_340nm[kg]";
				fSootIntegrals() << std::setw(20) << "pah34_400nm[kg]";
				fSootIntegrals() << std::setw(20) << "pahlarge_500nm[kg]";
				fSootIntegrals() << std::endl;
			}
			else
			{
				fSootIntegrals.reset(new std::ofstream("soot.integrals", std::ios::app));
				fSootIntegrals().setf(std::ios::scientific);
			}
		}
}

/*********************************************************************************************************************/ 

#if STEADYSTATE != 1

// Batch reactor homogeneous: ode parameters
const dictionary& odeHomogeneousDictionary = solverOptions.subDict("OdeHomogeneous");
OpenSMOKE::ODE_Parameters odeParameterBatchReactorHomogeneous;
{
	//- Mass fractions tolerance
	scalar relTolerance = readScalar(odeHomogeneousDictionary.lookup("relTolerance"));
	scalar absTolerance = readScalar(odeHomogeneousDictionary.lookup("absTolerance"));
	odeParameterBatchReactorHomogeneous.SetRelativeTolerance(relTolerance);
	odeParameterBatchReactorHomogeneous.SetAbsoluteTolerance(absTolerance);
	
	//- Full pivoting (only for OpenSMOKE solver)
	Switch fullPivoting(odeHomogeneousDictionary.lookup("fullPivoting"));
	odeParameterBatchReactorHomogeneous.SetFullPivoting(fullPivoting);
	
	//- Maximum order of integration (only for OpenSMOKE solver)
	label maximumOrder = readLabel(odeHomogeneousDictionary.lookup("maximumOrder"));
	odeParameterBatchReactorHomogeneous.SetMaximumOrder(maximumOrder);
	
	//- 
	
	// Type
	word homogeneousODESolverString(odeHomogeneousDictionary.lookup("odeSolver"));
	if (	homogeneousODESolverString != "OpenSMOKE" 	&& homogeneousODESolverString != "DVODE"  && 
			homogeneousODESolverString != "DLSODE" 		&& homogeneousODESolverString != "DLSODA" && 
			homogeneousODESolverString != "CVODE" 		&& homogeneousODESolverString != "DASPK"  &&
			homogeneousODESolverString != "MEBDF" 		&& homogeneousODESolverString != "RADAU5"  
	   )
	{
		Info << "Wrong homogeneous ODE Solver: OpenSMOKE || DVODE || DLSODE || DLSODA || CVODE || DASPK || MEBDF || RADAU5" << endl;
		abort();
	}

	if (homogeneousODESolverString == "OpenSMOKE")	odeParameterBatchReactorHomogeneous.SetType(OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_OPENSMOKE);
	if (homogeneousODESolverString == "DVODE") 		odeParameterBatchReactorHomogeneous.SetType(OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_DVODE);
	if (homogeneousODESolverString == "DLSODE") 	odeParameterBatchReactorHomogeneous.SetType(OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_DLSODE);
	if (homogeneousODESolverString == "DLSODA") 	odeParameterBatchReactorHomogeneous.SetType(OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_DLSODA);
	if (homogeneousODESolverString == "CVODE") 		odeParameterBatchReactorHomogeneous.SetType(OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_CVODE);
	if (homogeneousODESolverString == "DASPK") 		odeParameterBatchReactorHomogeneous.SetType(OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_DASPK);
	if (homogeneousODESolverString == "MEBDF") 		odeParameterBatchReactorHomogeneous.SetType(OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_MEBDF);
	if (homogeneousODESolverString == "RADAU5") 	odeParameterBatchReactorHomogeneous.SetType(OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_RADAU5);	
	
}


// Check type
{
	if (odeParameterBatchReactorHomogeneous.type() == OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_DVODE)
	{
		#if OPENSMOKE_USE_DVODE != 1
		{
			Info << "The solver was compiled without the DVODE support. Please choose a different ODE solver." << endl;
			abort();
		}
		#endif
	}
	else if (odeParameterBatchReactorHomogeneous.type() == OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_CVODE)
	{
		#if OPENSMOKE_USE_SUNDIALS != 1
		{
			Info << "The solver was compiled without the CVODE support. Please choose a different ODE solver." << endl;
			abort();
		}
		#endif
	}
	else if ( odeParameterBatchReactorHomogeneous.type() == OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_DLSODE ||
	          odeParameterBatchReactorHomogeneous.type() == OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_DLSODA )
	{
		#if OPENSMOKE_USE_ODEPACK != 1
		{
			Info << "The solver was compiled without the ODEPACK support. Please choose a different ODE solver." << endl;
			abort();
		}
		#endif
	}
	else if (odeParameterBatchReactorHomogeneous.type() == OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_RADAU5)
	{
		#if OPENSMOKE_USE_RADAU != 1
		{
			Info << "The solver was compiled without the RADAU support. Please choose a different ODE solver." << endl;
			abort();
		}
		#endif
	}	
	else if (odeParameterBatchReactorHomogeneous.type() == OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_DASPK)
	{
		#if OPENSMOKE_USE_DASPK != 1
		{
			Info << "The solver was compiled without the DASPK support. Please choose a different ODE solver." << endl;
			abort();
		}
		#endif
	}
	else if (odeParameterBatchReactorHomogeneous.type() == OpenSMOKE::ODE_Parameters::ODE_INTEGRATOR_MEBDF)
	{
		#if OPENSMOKE_USE_MEBDF != 1
		{
			Info << "The solver was compiled without the MEBDF support. Please choose a different ODE solver." << endl;
			abort();
		}
		#endif
	}			
}
#endif

#if STEADYSTATE != 1
#if OPENSMOKE_USE_ISAT == 1
    #include "readOptions_ISAT.H"
#endif
#endif

//label minMaxUpdate  = 25;
//label minMaxCounter = minMaxUpdate;

Info<< "Solver options correctly read\n" << endl;
